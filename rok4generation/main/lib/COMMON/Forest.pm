# Copyright © (2011) Institut national de l'information
#                    géographique et forestière 
# 
# Géoportail SAV <contact.geoservices@ign.fr>
# 
# This software is a computer program whose purpose is to publish geographic
# data using OGC WMS and WMTS protocol.
# 
# This software is governed by the CeCILL-C license under French law and
# abiding by the rules of distribution of free software.  You can  use, 
# modify and/ or redistribute the software under the terms of the CeCILL-C
# license as circulated by CEA, CNRS and INRIA at the following URL
# "http://www.cecill.info". 
# 
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability. 
# 
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or 
# data to be ensured and,  more generally, to use and operate it in the 
# same conditions as regards security. 
# 
# The fact that you are presently reading this means that you have had
# 
# knowledge of the CeCILL-C license and that you accept its terms.

################################################################################

=begin nd
File: Forest.pm

Class: COMMON::Forest

(see ROK4GENERATION/libperlauto/COMMON_Forest.png)

Creates and manages all graphs, <NNGraph> and <QTree>.

(see ROK4GENERATION/forest.png)

We have several kinds of graphs and their using have to be transparent for the forest. That's why we must define functions for all graph's types (as an interface) :
    - computeYourself() : <NNGraph::computeYourself>, <QTree::computeYourself>
    - containsNode(level, i, j) : <NNGraph::containsNode>, <QTree::containsNode>

Using:
    (start code)
    use COMMON::Forest

    my $Forest = COMMON::Forest->new(
        $objPyramid, # a COMMON::PyramidRaster or COMMON::PyramidVector object
        $objDSL, # a COMMON::DataSourceLoader object
        $param_process, # a hash with following keys : job_number, path_temp, path_temp_common and path_shell
    );
    (end code)

Attributes:
    pyramid - <COMMON::PyramidRaster> or <COMMON::PyramidVector> - Images' pyramid to generate, thanks to one or several graphs.
    graphs - <COMMON::QTree> or <COMMON::NNGraph> array - Graphs composing the forest, one per data source.
    scripts - <COMMON::Script> array - Scripts, whose execution generate the images' pyramid.
    splitNumber - integer - Number of script used for work parallelization.

=cut

################################################################################

package COMMON::Forest;

use strict;
use warnings;

use Log::Log4perl qw(:easy);
use Data::Dumper;
use List::Util qw(min max);
use Cwd;
use File::Spec;

# My module
use COMMON::QTree;
use COMMON::NNGraph;
use COMMON::Array;

use BE4::Shell;
use FOURALAMO::Shell;

use COMMON::PyramidRaster;
use COMMON::PyramidVector;
use COMMON::Script;
use COMMON::DataSourceLoader;
use COMMON::DataSource;

require Exporter;
use AutoLoader qw(AUTOLOAD);

our @ISA = qw(Exporter);

our %EXPORT_TAGS = ( 'all' => [ qw() ] );
our @EXPORT_OK   = ( @{$EXPORT_TAGS{'all'}} );
our @EXPORT      = qw();

################################################################################
# Constantes
use constant TRUE  => 1;
use constant FALSE => 0;

################################################################################

BEGIN {}
INIT {}
END {}

####################################################################################################
#                                        Group: Constructors                                       #
####################################################################################################

=begin nd
Constructor: new

Forest constructor. Bless an instance.

Parameters (list):
    pyramid - <COMMON::PyramidRaster> or <COMMON::PyramidVector> - Output pyramid, generated by this forest.
    DSL - <COMMON::DataSourceLoader> - Contains one or several data sources
    params_process - hash - Informations for scripts
|               job_number - integer - Parallelization level
|               path_temp - string - Temporary directory
|               path_temp_common - string - Common temporary directory
|               path_shell - string - Script directory

See also:
    <_load>
=cut
sub new {
    my $class = shift;
    my $pyramid = shift;
    my $DSL = shift;
    my $params_process = shift;

    $class = ref($class) || $class;
    # IMPORTANT : if modification, think to update natural documentation (just above)
    my $this = {
        pyramid     => undef,
        graphs      => [],
        scripts     => {},
        splitNumber => undef
    };

    bless($this, $class);

    # it's an object and it's mandatory !
    if (! defined $pyramid || (ref ($pyramid) ne "COMMON::PyramidRaster" && ref ($pyramid) ne "COMMON::PyramidVector")) {
        ERROR("We need a COMMON::PyramidRaster or COMMON::PyramidVector to create a Forest");
        return undef;
    }
    $this->{pyramid} = $pyramid;
    
    # it's an object and it's mandatory !
    if (! defined $DSL || ref ($DSL) ne "COMMON::DataSourceLoader") {
        ERROR("We need a COMMON::DataSourceLoader to create a Forest");
        return undef;
    }

    if (! defined $params_process) {
        ERROR("We need process' parameters to create a Forest");
        return undef;
    }
    
    # load. class
    return undef if (! $this->_load($DSL, $params_process) );
    
    INFO (sprintf "Graphs' number : %s",scalar @{$this->{graphs}});

    return $this;
}

=begin nd
Function: _load

Creates a <COMMON::NNGraph> or a <COMMON::QTree> object per data source. Using a QTree is faster but it does'nt match all cases.

All differences between different kinds of graphs are handled in respective classes, in order to be imperceptible for users.

Only scripts creation and initial organization are managed by the forest.

Parameters (list):
    DSL - <COMMON::DataSourceLoader> - Contains one or several data sources
    params_process - hash - Informations for scipts, where to write them, temporary directory to use...
|               job_number - integer - Parallelization level
|               path_temp - string - Temporary directory
|               path_temp_common - string - Common temporary directory
|               path_shell - string - Script directory

=cut
sub _load {
    my $this = shift;
    my $DSL = shift;
    my $params_process = shift;

    my $dataSources = $DSL->getDataSources();
    my $TMS = $this->{pyramid}->getTileMatrixSet();
    my $isQTree = $TMS->isQTree();

    ######### TESTS DE TYPE ###########

    if (ref ($this->{pyramid}) eq "COMMON::PyramidVector") {
        if ($DSL->getType() ne "VECTOR") {
            ERROR("Datasources must have VECTOR type to generate a vector pyramid");
            return FALSE;
        }
        if (! $isQTree) {
            ERROR("Only QuadTree is handled for vector pyramid");
            return FALSE;
        }
    }
    elsif (ref ($this->{pyramid}) eq "COMMON::PyramidRaster") {
        if ($DSL->getType() ne "RASTER") {
            ERROR("Datasources must have RASTER type to generate a raster pyramid");
            return FALSE;
        }
    }
    
    ######### PARAM PROCESS ###########
    
    $this->{splitNumber} = $params_process->{job_number};
    my $tempDir = File::Spec->rel2abs($params_process->{path_temp});
    my $commonTempDir = File::Spec->rel2abs($params_process->{path_temp_common});
    my $scriptDir = File::Spec->rel2abs($params_process->{path_shell});

    if (! defined $this->{splitNumber}) {
        ERROR("Parameter required : 'job_number' in section 'Process' !");
        return FALSE;
    }

    if (! defined $tempDir) {
        ERROR("Parameter required : 'path_temp' in section 'Process' !");
        return FALSE;
    }

    if (! defined $commonTempDir) {
        ERROR("Parameter required : 'path_temp_common' in section 'Process' !");
        return FALSE;
    }

    if (! defined $scriptDir) {
        ERROR("Parameter required : 'path_shell' in section 'Process' !");
        return FALSE;
    }

    # Ajout du nom de la pyramide aux dossiers temporaires (pour distinguer de ceux des autres générations)
    $tempDir = File::Spec->catdir($tempDir,$this->{pyramid}->getName() );
    $commonTempDir = File::Spec->catdir($commonTempDir,$this->{pyramid}->getName() );

    ############# SHELL #############

    my $scriptInit = undef;
    if (ref ($this->{pyramid}) eq "COMMON::PyramidRaster") {
        # Si on génère une pyramide raster, c'est que nous utilisons l'outil BE4, et des variables sont à initialiser dans la librairie des commandes Shell pour BE4

        if ($this->{pyramid}->ownMasks()) {
            # Si on souhaite avoir des masques dans la pyramide de sortie, il faut les utiliser tout du long des calculs
            $params_process->{use_masks} = "TRUE";
        }

        if (! BE4::Shell::setGlobals($this->{splitNumber}, $tempDir, $commonTempDir, $scriptDir, $params_process->{use_masks})) {
            ERROR ("Impossible d'initialiser la librairie des commandes Shell pour BE4");
            return FALSE;
        }
        $scriptInit = BE4::Shell::getScriptInitialization($this->{pyramid});
    } else {
        if (! FOURALAMO::Shell::setGlobals($this->{splitNumber}, $tempDir, $commonTempDir, $scriptDir)) {
            ERROR ("Impossible d'initialiser la librairie des commandes Shell pour 4ALAMO");
            return FALSE;
        }
        $scriptInit = FOURALAMO::Shell::getScriptInitialization($this->{pyramid});
    }
    
    ############# SCRIPTS #############
    # We create COMMON::Script objects and initialize them (header)

    if ($isQTree) {
        #### QTREE CASE
        $this->{scripts} = COMMON::QTree::defineScripts($scriptInit, $this->{pyramid});
    } else {
        #### NN GRAPH CASE
        $this->{scripts} = COMMON::NNGraph::defineScripts($scriptInit, $this->{pyramid});
    }
    
    ############# GRAPHS #############

    foreach my $datasource (@{$dataSources}) {
        
        # Creation of QTree or NNGraph object
        my $graph = undef;
        if ($isQTree) {
            $graph = COMMON::QTree->new($this, $datasource);
        } else {
            $graph = COMMON::NNGraph->new($this, $datasource);
        };
                
        if (! defined $graph) {
            ERROR(sprintf "Can not create a graph for datasource with bottom level %s !", $datasource->getBottomID());
            return FALSE;
        }
        
        push @{$this->{graphs}},$graph;
    }

    return TRUE;
}


####################################################################################################
#                                  Group: Graphs tools                                             #
####################################################################################################

=begin nd
Function: containsNode

Returns a boolean : TRUE if the node belong to this forest, FALSE otherwise (if a parameter is not defined too).

Parameters (list):
    level - string - Level ID of the node we want to know if it is in the forest.
    col - integer - Column of the node we want to know if it is in the forest.
    row - integer - Row of the node we want to know if it is in the forest.
=cut
sub containsNode {
    my $this = shift;
    my $level = shift;
    my $col = shift;
    my $row = shift;

    return FALSE if (! defined $level || ! defined $col || ! defined $row);
    
    foreach my $graph (@{$this->{graphs}}) {
        return TRUE if ($graph->containsNode($level,$col,$row));
    }
    
    return FALSE;
}

=begin nd
Function: computeGraphs

Computes each <COMMON::NNGraph> or <COMMON::QTree> one after the other and closes scripts to finish.

See Also:
    <COMMON::NNGraph::computeYourself>, <COMMON::QTree::computeYourself>
=cut
sub computeGraphs {
    my $this = shift;
    
    my $graphInd = 1;
    my $graphNumber = scalar @{$this->{graphs}};
    
    foreach my $graph (@{$this->{graphs}}) {
        if (! $graph->computeYourself()) {
            ERROR(sprintf "Cannot compute graph $graphInd/$graphNumber");
            return FALSE;
        }
        INFO("Graph $graphInd/$graphNumber computed");
        $graphInd++;
    }
    
    if ($this->{pyramid}->getTileMatrixSet()->isQTree()) {
        COMMON::QTree::closeScripts($this->{scripts});
    } else {
        COMMON::NNGraph::closeScripts($this->{scripts});
    }
    
    return TRUE;
}

####################################################################################################
#                                Group: Getters - Setters                                          #
####################################################################################################

# Function: getGraphs
sub getGraphs {
    my $this = shift;
    return $this->{graphs}; 
}

# Function: getPyramid
sub getPyramid {
    my $this = shift;
    return $this->{pyramid}; 
}

# Function: getScripts
sub getScripts {
    my $this = shift;
    return $this->{scripts};
}

####################################################################################################
#                                Group: Export methods                                             #
####################################################################################################

=begin nd
Function: exportForDebug

Returns all informations about the forest. Useful for debug.

Example:
    (start code)
    (end code)
=cut
sub exportForDebug {
    my $this = shift ;
    
    my $export = "";
    
    $export .= sprintf "\n Object COMMON::Forest :\n";

    $export .= "\t Graph :\n";
    $export .= sprintf "\t Number of graphs in the forest : %s\n", scalar @{$this->{graphs}};
    
    $export .= "\t Scripts :\n";
    $export .= sprintf "\t Parallelization level : %s\n", $this->{splitNumber};
    
    return $export;
}

1;
__END__
